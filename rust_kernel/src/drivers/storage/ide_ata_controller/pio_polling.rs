//! This files contains the code related to the ATA PIO MODE
/// See https://wiki.osdev.org/ATA_PIO_Mode

#[deny(missing_docs)]

use super::Drive;
use super::SECTOR_SIZE;
use super::{check_bounds, AtaError, AtaResult, Capabilities, DeviceControlRegister, Hierarchy, Rank};
use super::{Command, ErrorRegister, StatusRegister};

use crate::drivers::storage::tools::*;

use io::{Io, Pio};

use bit_field::BitField;

use alloc::vec::Vec;

use core::slice;

/// 0x01F0-0x01F7 The primary ATA hard-disk controller. 0x03F6-0x03F7 The control register, pop on IRQ14,
/// 0x0170-0x0177 The secondary ATA hard-disk controller. 0x0376-0x0377 The control register, pop on IRQ15
impl Drive {
    /// *** These below constants are expressed with offset from base register ***
    /// Data Register: Read/Write PIO data bytes. (read/write) (16-bit / 16-bit)
    const DATA: u16 = 0x0;

    /// Error Register: Used to retrieve any error generated by the last ATA command executed. (read) (8-bit / 16-bit)
    /// Features Register: Used to control command specific interface features. (write) (8-bit / 16-bit)
    const ERROR: u16 = 0x1;
    const FEATURES: u16 = 0x1;

    /// Sector Count Register:  Number of sectors to read/write (0 is a special value). (read/write) (8-bit / 16-bit)
    const SECTOR_COUNT: u16 = 0x2;

    /// Sector Number Register or LBA low. (read/write) (8-bit / 16-bit)
    const L1_SECTOR: u16 = 0x3;

    /// Cylinder Low Register or LBA mid. (read/write) (8-bit / 16-bit)
    const L2_CYLINDER: u16 = 0x4;

    /// Cylinder High Register or LBA high. (read/write) (8-bit / 16-bit)
    const L3_CYLINDER: u16 = 0x5;

    /// Drive / Head Register: Used to select a drive and/or head. Supports extra address/flag bits. (read/write) (8-bit / 8-bit)
    const SELECTOR: u16 = 0x6;

    /// Status Register: Used to read the current status. (read) (8-bit / 8-bit)
    /// Command Register:  Used to send ATA commands to the device. (write) (8-bit / 8-bit)
    const STATUS: u16 = 0x7;
    const COMMAND: u16 = 0x7;

    /// *** These below constants are expressed with offset from control register ***
    /// A duplicate of the Status Register which does not affect interrupts. (read) (8-bit / 8-bit)
    /// Used to reset the bus or enable/disable interrupts. (write) (8-bit / 8-bit)
    const ALTERNATE_STATUS: u16 = 0x0;
    const DEVICE_CONTROL: u16 = 0x0;

    /// Provides drive select and head select information. (read) (8-bit / 8-bit)
    const _DRIVE_ADDRESS: u16 = 0x1;

    /// Check if the selected IDE device is present, return characteristics if it is
    pub fn identify(rank: Rank, command_register: u16, control_register: u16) -> Option<Drive> {
        let target = match rank {
            Rank::Primary(Hierarchy::Master) => 0xA0,
            Rank::Primary(Hierarchy::Slave) => 0xB0,
            Rank::Secondary(Hierarchy::Master) => 0xA0,
            Rank::Secondary(Hierarchy::Slave) => 0xB0,
        };

        // select a target drive by sending 0xA0 for the master drive, or 0xB0 for the slave
        Pio::<u8>::new(command_register + Self::SELECTOR).write(target);

        // set the Sectorcount, LBAlo, LBAmid, and LBAhi IO ports to 0
        Pio::<u8>::new(command_register + Self::SECTOR_COUNT).write(0);
        Pio::<u8>::new(command_register + Self::L1_SECTOR).write(0);
        Pio::<u8>::new(command_register + Self::L2_CYLINDER).write(0);
        Pio::<u8>::new(command_register + Self::L3_CYLINDER).write(0);

        // send the IDENTIFY command (0xEC) to the Command IO port (0x1F7)
        Pio::<u8>::new(command_register + Self::COMMAND).write(Command::AtaCmdIdentify as u8);

        // read the Status port (0x1F7). If the value read is 0, the drive does not exist
        if Pio::<u8>::new(command_register + Self::STATUS).read() == 0 {
            return None;
        }

        // For any other value: poll the Status port (0x1F7) until bit 7 (BSY, value = 0x80) clears
        while (StatusRegister::from_bits_truncate(Pio::<u8>::new(command_register + Self::STATUS).read()))
            .contains(StatusRegister::BSY)
        {}

        // Continue polling one of the Status ports until bit 3 (DRQ, value = 8) sets, or until bit 0 (ERR, value = 1) sets.
        while !(StatusRegister::from_bits_truncate(Pio::<u8>::new(command_register + Self::STATUS).read()))
            .intersects(StatusRegister::ERR | StatusRegister::DRQ)
        {}

        // If ERR is set, it is a failure
        if (StatusRegister::from_bits_truncate(Pio::<u8>::new(command_register + Self::STATUS).read()))
            .contains(StatusRegister::ERR)
        {
            eprintln!(
                "unexpected error while polling status of {:?} err: {:?}",
                rank,
                ErrorRegister::from_bits_truncate(Pio::<u8>::new(command_register + Self::ERROR).read())
            );
            return None;
        }

        // if ERR is clear, the data is ready to read from the Data port (0x1F0). Read 256 16-bit values, and store them.
        let mut v = Vec::new();

        for _i in 0..256 {
            v.push(Pio::<u16>::new(command_register + Self::DATA).read());
        }

        // Bit 10 is set if the drive supports LBA48 mode.
        // 100 through 103 taken as a uint64_t contain the total number of 48 bit addressable sectors on the drive. (Probably also proof that LBA48 is supported.)
        if v[83] & (1 << 10) != 0 {
            Some(Drive {
                capabilities: Capabilities::Lba48,
                sector_capacity: NbrSectors(
                    v[100] as u64 + ((v[101] as u64) << 16) + ((v[102] as u64) << 32) + ((v[103] as u64) << 48),
                ),
                // The bits in the low byte tell you the supported UDMA modes, the upper byte tells you which UDMA mode is active.
                udma_support: v[88],
                command_register,
                control_register,
                rank,
            })
        // 60 & 61 taken as a uint32_t contain the total number of 28 bit LBA addressable sectors on the drive. (If non-zero, the drive supports LBA28.)
        } else if v[60] != 0 || v[61] != 0 {
            Some(Drive {
                capabilities: Capabilities::Lba28,
                sector_capacity: NbrSectors(v[60] as u64 + ((v[61] as u64) << 16)),
                udma_support: v[88],
                command_register,
                control_register,
                rank,
            })
        } else {
            Some(Drive {
                capabilities: Capabilities::Chs,
                sector_capacity: NbrSectors(0),
                udma_support: v[88],
                command_register,
                control_register,
                rank,
            })
        }
    }

    /// drive specific READ method
    pub fn read(&self, start_sector: Sector, nbr_sectors: NbrSectors, buf: *mut u8) -> AtaResult<()> {
        check_bounds(start_sector, nbr_sectors, self.sector_capacity)?;

        let s = unsafe { slice::from_raw_parts_mut(buf, nbr_sectors.into()) };

        match self.capabilities {
            Capabilities::Lba48 => {
                // Do disk operation for each 'chunk_size' bytes
                const CHUNK_SIZE: usize = SECTOR_SIZE * 256 * 256;

                for (i, chunk) in s.chunks_mut(CHUNK_SIZE).enumerate() {
                    let sectors_to_read = chunk.len().into();

                    self.init_lba48(start_sector + (i * CHUNK_SIZE).into(), sectors_to_read);

                    // Send the "READ SECTORS EXT" command (0x24) to port 0x1F7: outb(0x1F7, 0x24)
                    self.wait_available();
                    Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdReadPioExt as u8);

                    // Read n sectors and put them into buf
                    self.read_sectors(sectors_to_read, chunk.as_mut_ptr())?;
                }
                Ok(())
            }
            Capabilities::Lba28 => {
                // Do disk operation for each 'chunk_size' bytes
                const CHUNK_SIZE: usize = SECTOR_SIZE * 256;

                for (i, chunk) in s.chunks_mut(CHUNK_SIZE).enumerate() {
                    let sectors_to_read = chunk.len().into();

                    self.init_lba28(start_sector + (i * CHUNK_SIZE).into(), sectors_to_read);

                    // Send the "READ SECTORS" command (0x20) to port 0x1F7: outb(0x1F7, 0x20)
                    self.wait_available();
                    Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdReadPio as u8);

                    // Read n sectors and put them into buf
                    self.read_sectors(sectors_to_read, chunk.as_mut_ptr())?;
                }
                Ok(())
            }
            // I experiment a lack of documentation about this mode
            Capabilities::Chs => Err(AtaError::NotSupported),
        }
    }

    /// Drive specific WRITE method
    pub fn write(&self, start_sector: Sector, nbr_sectors: NbrSectors, buf: *const u8) -> AtaResult<()> {
        check_bounds(start_sector, nbr_sectors, self.sector_capacity)?;

        let s = unsafe { slice::from_raw_parts(buf, nbr_sectors.into()) };

        match self.capabilities {
            Capabilities::Lba48 => {
                // Do disk operation for each 'chunk_size' bytes (32mo max for lba48)
                const CHUNK_SIZE: usize = SECTOR_SIZE * 256 * 256;

                for (i, chunk) in s.chunks(CHUNK_SIZE).enumerate() {
                    let sectors_to_write = chunk.len().into();

                    self.init_lba48(start_sector + (i * CHUNK_SIZE).into(), sectors_to_write);

                    // Send the "WRITE SECTORS EXT" command (0x34) to port 0x1F7: outb(0x1F7, 0x34)
                    self.wait_available();
                    Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdWritePioExt as u8);

                    // Write n sectors from buf to disk
                    self.write_sectors(sectors_to_write, chunk.as_ptr())?;

                    // Fflush write cache
                    self.fflush_write_cache();
                }
                Ok(())
            }
            Capabilities::Lba28 => {
                // Do disk operation for each 'chunk_size' bytes (32k max for lba28)
                const CHUNK_SIZE: usize = SECTOR_SIZE * 256;

                for (i, chunk) in s.chunks(CHUNK_SIZE).enumerate() {
                    let sectors_to_write = chunk.len().into();

                    self.init_lba28(start_sector + (i * CHUNK_SIZE).into(), sectors_to_write);

                    // Send the "WRITE SECTORS" command (0x30) to port 0x1F7: outb(0x1F7, 0x30)
                    self.wait_available();
                    Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdWritePio as u8);

                    // Write n sectors from buf to disk
                    self.write_sectors(sectors_to_write, chunk.as_ptr())?;

                    // Fflush write cache
                    self.fflush_write_cache();
                }
                Ok(())
            }
            // I experiment a lack of documentation about this mode
            Capabilities::Chs => Err(AtaError::NotSupported),
        }
    }

    /// Read n_sectors, store them into buf
    fn read_sectors(&self, nbr_sectors: NbrSectors, buf: *const u8) -> AtaResult<()> {
        for sector in 0..nbr_sectors.0 as usize {
            // Wait for end of Busy state and DRQ ready
            self.busy_wait()?;

            let p = buf as *mut u16;
            for i in 0..SECTOR_SIZE >> 1 {
                unsafe {
                    *p.add(i + sector * (SECTOR_SIZE >> 1)) = Pio::<u16>::new(self.command_register + Self::DATA).read()
                }
            }
        }
        Ok(())
    }

    /// Write n sectors from buf
    fn write_sectors(&self, nbr_sectors: NbrSectors, buf: *const u8) -> AtaResult<()> {
        for sector in 0..nbr_sectors.0 as usize {
            // Wait for end of Busy state and DRQ ready
            self.busy_wait()?;

            let p = buf as *const u16;
            for i in 0..SECTOR_SIZE >> 1 {
                unsafe {
                    Pio::<u16>::new(self.command_register + Self::DATA).write(*p.add(i + sector * (SECTOR_SIZE >> 1)))
                }
            }
        }
        Ok(())
    }

    /// Wait for end of Busy state and DRQ ready
    fn busy_wait(&self) -> AtaResult<()> {
        loop {
            let r = StatusRegister::from_bits_truncate(Pio::<u8>::new(self.command_register + Self::STATUS).read());
            if r.contains(StatusRegister::ERR) {
                eprintln!(
                    "unexpected error while busy of {:?} err: {:?}",
                    self.rank,
                    ErrorRegister::from_bits_truncate(Pio::<u8>::new(self.command_register + Self::ERROR).read())
                );
                return Err(AtaError::IoError);
            }
            if !r.contains(StatusRegister::BSY) && r.contains(StatusRegister::DRQ) {
                break;
            }
        }
        Ok(())
    }

    /// On some drives it is necessary to "manually" flush the hardware write cache after every write command.
    /// This is done by sending the 0xE7 command to the Command Register (then waiting for BSY to clear).
    /// If a driver does not do this, then subsequent write commands can fail invisibly,
    /// or "temporary bad sectors" can be created on your disk.
    fn fflush_write_cache(&self) {
        match self.capabilities {
            Capabilities::Lba28 => {
                Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdCacheFlush as u8)
            }
            Capabilities::Lba48 => {
                Pio::<u8>::new(self.command_register + Self::COMMAND).write(Command::AtaCmdCacheFlushExt as u8)
            }
            _ => {}
        };

        let p = Pio::<u8>::new(self.command_register + Self::STATUS);
        while StatusRegister::from_bits_truncate(p.read()).contains(StatusRegister::BSY) {}
    }

    /// The method suggested in the ATA specs for sending ATA commands tells you to check the BSY and DRQ bits before trying to send a command
    fn wait_available(&self) {
        // Continue polling one of the Status ports until bit 3 (DRQ, value = 8) sets, or until bit 0 (BSY, value = 7) sets.
        while StatusRegister::from_bits_truncate(Pio::<u8>::new(self.control_register + Self::ALTERNATE_STATUS).read())
            .intersects(StatusRegister::BSY | StatusRegister::DRQ)
        {}
    }

    /// Init read or write sequence for lba48 mode
    fn init_lba48(&self, start_sector: Sector, nbr_sectors: NbrSectors) {
        let lba_low = start_sector.0.get_bits(0..32) as u32;
        let lba_high = start_sector.0.get_bits(32..48) as u32;

        // Send 0x40 for the "master" or 0x50 for the "slave" to port 0x1F6: outb(0x1F6, 0x40 | (slavebit << 4))
        self.wait_available();
        match self.get_hierarchy() {
            Hierarchy::Master => Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0x40),
            Hierarchy::Slave => Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0x50),
        }

        // Outb (0x1F2, sectorcount high byte)
        Pio::<u8>::new(self.command_register + Self::SECTOR_COUNT).write(nbr_sectors.0.get_bits(8..16) as u8);

        // LBA 4
        Pio::<u8>::new(self.command_register + Self::L1_SECTOR).write(lba_low.get_bits(24..32) as u8);
        // LBA 5
        Pio::<u8>::new(self.command_register + Self::L2_CYLINDER).write(lba_high.get_bits(0..8) as u8);
        // LBA 6
        Pio::<u8>::new(self.command_register + Self::L3_CYLINDER).write(lba_high.get_bits(8..16) as u8);

        // outb (0x1F2, sectorcount low byte)
        Pio::<u8>::new(self.command_register + Self::SECTOR_COUNT).write(nbr_sectors.0.get_bits(0..8) as u8);

        // LBA 1
        Pio::<u8>::new(self.command_register + Self::L1_SECTOR).write(lba_low.get_bits(0..8) as u8);
        // LBA 2
        Pio::<u8>::new(self.command_register + Self::L2_CYLINDER).write(lba_low.get_bits(8..16) as u8);
        // LBA 3
        Pio::<u8>::new(self.command_register + Self::L3_CYLINDER).write(lba_low.get_bits(16..24) as u8);
    }

    /// Init read or write sequence for lba28 mode
    fn init_lba28(&self, start_sector: Sector, nbr_sectors: NbrSectors) {
        let lba_low = start_sector.0.get_bits(0..32) as u32;

        // Send 0xE0 for the "master" or 0xF0 for the "slave" to port 0x1F6
        // and add the highest 4 bits of the LBA to port 0x1F6: outb(0x1F6, 0xE0 | (slavebit << 4) | ((LBA >> 24) & 0x0F))
        self.wait_available();
        match self.get_hierarchy() {
            Hierarchy::Master => {
                Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0xE0 | ((lba_low >> 24) & 0xF) as u8)
            }
            Hierarchy::Slave => {
                Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0xF0 | ((lba_low >> 24) & 0xF) as u8)
            }
        }

        // Send a NULL byte to port 0x1F1, if you like (it is ignored and wastes lots of CPU time): outb(0x1F1, 0x00)
        Pio::<u8>::new(self.command_register + Self::FEATURES).write(0);

        // outb (0x1F2, sectorcount low byte)
        Pio::<u8>::new(self.command_register + Self::SECTOR_COUNT).write(nbr_sectors.0.get_bits(0..8) as u8);

        // LBA 1
        Pio::<u8>::new(self.command_register + Self::L1_SECTOR).write(lba_low.get_bits(0..8) as u8);
        // LBA 2
        Pio::<u8>::new(self.command_register + Self::L2_CYLINDER).write(lba_low.get_bits(8..16) as u8);
        // LBA 3
        Pio::<u8>::new(self.command_register + Self::L3_CYLINDER).write(lba_low.get_bits(16..24) as u8);
    }

    /// Extract the sub tag hierarchy from rank
    fn get_hierarchy(&self) -> Hierarchy {
        match self.rank {
            Rank::Primary(h) | Rank::Secondary(h) => h,
        }
    }

    /// Select the drive for future read and write operations
    pub fn select_drive(&self) {
        self.wait_available();
        match self.get_hierarchy() {
            // select a target drive by sending 0xA0 for the master drive, or 0xB0 for the slave
            // I dont think it is necessary or really true
            Hierarchy::Master => Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0xA0),
            Hierarchy::Slave => Pio::<u8>::new(self.command_register + Self::SELECTOR).write(0xB0),
        };
        // Disable interruot bit for the selected drive
        Pio::<u8>::new(self.control_register + Self::DEVICE_CONTROL).write(DeviceControlRegister::NIEN.bits());
    }
}

#[no_mangle]
fn primary_hard_disk_interrupt_handler() -> u32 {
    0
}

#[no_mangle]
fn secondary_hard_disk_interrupt_handler() -> u32 {
    0
}
