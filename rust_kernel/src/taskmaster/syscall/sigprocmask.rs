use super::scheduler::SCHEDULER;
use super::signal_interface::sigset_t;
use super::SysResult;

/// In a single-threaded process, the sigprocmask() function shall
/// examine or change (or both) the signal mask of the calling thread.
///
/// If the argument set is not a null pointer, it points to a set of
/// signals to be used to change the currently blocked set.
///
/// The argument how indicates the way in which the set is changed,
/// and the application shall ensure it consists of one of the
/// following values:
///
/// SIG_BLOCK The resulting set shall be the union of the current set
///     and the signal set pointed to by set.
/// SIG_SETMASK The resulting set shall be the signal set pointed to
///     by set.
/// SIG_UNBLOCK The resulting set shall be the intersection of the
///     current set and the complement of the signal set pointed to by
///     set.
///
/// If the argument oset is not a null pointer, the previous mask
/// shall be stored in the location pointed to by oset. If set is a
/// null pointer, the value of the argument how is not significant and
/// the thread's signal mask shall be unchanged; thus the call can be
/// used to enquire about currently blocked signals.
///
/// If there are any pending unblocked signals after the call to
/// sigprocmask(), at least one of those signals shall be delivered
/// before the call to sigprocmask() returns.
///
/// It is not possible to block those signals which cannot be
/// ignored. This shall be enforced by the system without causing an
/// error to be indicated.
///
/// If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are
/// generated while they are blocked, the result is undefined, unless
/// the signal was generated by the action of another process, or by
/// one of the functions kill(), pthread_kill(), raise(), or
/// sigqueue().
///
/// If sigprocmask() fails, the thread's signal mask shall not be
/// changed.
pub fn sys_sigprocmask(how: u32, set: *const sigset_t, oldset: *mut sigset_t) -> SysResult<u32> {
    unpreemptible_context!({
        let mut scheduler = SCHEDULER.lock();
        let checked_oldset;
        let checked_set;
        {
            let v = scheduler
                .current_thread_mut()
                .unwrap_process_mut()
                .get_virtual_allocator();

            // Check if pointer exists in user virtual address space
            checked_set = if set.is_null() {
                None
            } else {
                Some(v.make_checked_ref(set)?)
            };
            checked_oldset = if oldset.is_null() {
                None
            } else {
                Some(v.make_checked_ref_mut(oldset)?)
            };
        }
        scheduler
            .current_thread_mut()
            .signal
            .change_signal_mask(how, checked_set, checked_oldset)
    })
}
