//! This files contains the code related to the ATA / IDE CONTROLER
/// See https://wiki.osdev.org/ATA_PIO_Mode

//use io::{Io, Pio};
//use bit_field::BitField;

//use super::DeviceError;
//use super::DeviceResult;

#[derive(Debug, Copy, Clone)]
pub struct DummyAta {
    primary_base_register: u16,
    secondary_base_register: u16,
    primary_control_register: u16,
    secondary_control_register: u16,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Rank {
    Primary,
    Secondary,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Hierarchy {
    Master,
    Souillon,
}

/// LBA 48 CONFIGURATION
/// 0x01F0-0x01F7 The primary ATA hard-disk controller. 0x03F6-0x03F7 The control register, pop on IRQ14,
/// 0x0170-0x0177 The secondary ATA hard-disk controller. 0x0376-0x0377 The control register, pop on IRQ15
#[allow(dead_code)]
impl DummyAta {
    /// Standard port location, if they are different, probe IDE controller in PCI driver
    const PRIMARY_BASE_REGISTER: u16 = 0x01F0;
    const SECONDARY_BASE_REGISTER: u16 = 0x0170;
    const PRIMARY_CONTROL_REGISTER: u16 = 0x03f6;
    const SECONDARY_CONTROL_REGISTER: u16 = 0x376;

    /// magic word to read or write. Bit 6 (value = 0x40) is the LBA bit
    const MAGIC_MASTER_COMMAND_BYTE: u8 = 0x40;
    const MAGIC_SOUILLON_COMMAND_BYTE: u8 = 0x50;

    /// *** These below constants are expressed with offset from base register ***
    /// Data Register: Read/Write PIO data bytes. (read/write) (16-bit / 16-bit)
    const DATA: u16 = 0x0;

    /// Error Register: Used to retrieve any error generated by the last ATA command executed. (read) (8-bit / 16-bit)
    /// Features Register: Used to control command specific interface features. (write) (8-bit / 16-bit)
    const ERROR: u16 = 0x1;
    const FEATURES: u16 = 0x1;

    /// Sector Count Register:  Number of sectors to read/write (0 is a special value). (read/write) (8-bit / 16-bit)
    const SECTOR_COUNT: u16 = 0x2;

    /// Sector Number Register or LBA low. (read/write) (8-bit / 16-bit)
    const L1_SECTOR: u16 = 0x3;

    /// Cylinder Low Register or LBA mid. (read/write) (8-bit / 16-bit)
    const L2_CYLINDER: u16 = 0x4;

    /// Cylinder High Register or LBA high. (read/write) (8-bit / 16-bit)
    const L3_CYLINDER: u16 = 0x5;

    /// Drive / Head Register: Used to select a drive and/or head. Supports extra address/flag bits. (read/write) (8-bit / 8-bit)
    const SELECTOR: u16 = 0x6;

    /// Status Register: Used to read the current status. (read) (8-bit / 8-bit)
    /// Command Register:  Used to send ATA commands to the device. (write) (8-bit / 8-bit)
    const STATUS: u16 = 0x7;
    const COMMAND: u16 = 0x7;

    /// *** These below constants are expressed with offset from control register ***
    /// A duplicate of the Status Register which does not affect interrupts. (read) (8-bit / 8-bit)
    /// Used to reset the bus or enable/disable interrupts. (write) (8-bit / 8-bit)
    const ALTERNATE_STATUS: u16 = 0x0;
    const DEVICE_CONTROL: u16 = 0x0;

    /// Provides drive select and head select information. (read) (8-bit / 8-bit)
    const DRIVE_ADDRESS: u16 = 0x1;

    /// Invoque a new Dummy-IDE controller
    pub const fn new() -> Self {
        Self {
            primary_base_register: Self::PRIMARY_BASE_REGISTER,
            secondary_base_register: Self::SECONDARY_BASE_REGISTER,
            primary_control_register: Self::PRIMARY_CONTROL_REGISTER,
            secondary_control_register: Self::SECONDARY_CONTROL_REGISTER,
        }
    }
}

#[no_mangle]
fn primary_hard_disk_interrupt_handler() -> u32 {
    0
}

#[no_mangle]
fn secondary_hard_disk_interrupt_handler() -> u32 {
    0
}
